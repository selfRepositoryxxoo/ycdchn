<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    什么叫做面向对象?
//->JS就是基于面向对象的思想开发的,浏览器提供了很多的类,我们还可以自己定义类(构造函数模式),我们平时所用的一般都是某一个类的实例
    ->如果想把JS学好,只需要按照面向对象的思想,研究实例和具体的类即可;
    //所有对象划分成类，然后针对某个实例进行研究，通过对这个实例的认识认识这个类中的任何实例
//->需要我们掌握类的继承、封装、多态
1.对象的组成：属性和方法
    oop:Object Oriented Programming
    oo或oop思想：面向对象思想，面向对象的模式有二十多种，课下看一下。
   面向过程：以过程为中心。函数的里为了实现某个而效果实现的就是过程。
   面向对象：是以事物为中心
2.********js中面向对象编程（oop）的特点：**********************
    1）封装：低耦合高内聚
    封装方法思路：
        1.首先知道这个而函数的需求
        2.知道返回值是什么类型的
    2）继承：子类继承父类的属性和方法
    继承：子类继承父类的属性和方法；
*****原型继承：是基于原型链的*******
        call继承：实现私有属性和私有方法的继承；（具体可以查看正式课第一周周日的讲义--拷贝继承）
        拷贝继承：for in 循环实现；（通过遍历，可以将一个对象的属性和属性值拷贝给另一个对象，然后对新的对象进行操作，就不影响父级）
        原型继承：是js中最常用的一种方式，子类B想要继承A中的所有属性和方法（私有+公有），只需要让B.prototype=new A即可。
        因为A的实例拥有这些属性和方法。不是复制一份过来，而是在A和B的原型之间搭建一个桥梁，B的实例可以通过A的实例查找到A的原型对象上的方法。
        //原型继承特点：它是把父类中私有的+公有的都继承到子类的原型上了（变成了子类公有的）。
    3）多态：多种形态，包括重载和重写
        a.重载：js中相同函数名，后面的会把前面的覆盖掉，所以js中不存在重载；但js中有类似重载的思想，即传不同的参数实现不同的效果
        b.重写：子类可以重写父类的方法：

3.*****面向对象（oop)的常用模式：单例模式、工厂模式、构造函数模式、原型模式**********************
一）单例模式
    单例模式：把描述同一事物的属性和方法，放在同一个命名空间下进行分组；避免不同事物相同属性，变量名冲突的问题。
    单例模式本质：一个对象********
    命名空间：浏览器开辟一个堆内存，给这个内存附上一个名字，比如person1就是命名空间；
    1.模块化开发：对于一个大型项目，分给不同的工程师去完成不同的模块，全部完成之后，把所有模块拼接到一起，
        整个项目就完成了。（避免变量名冲突，可以同步开发）；
        1）单例模式就是最简单的模块化开发；（seaJS,RequireJS）课下了解
        2）单例模式中可进行各模块之间的相互调用   模块名.属性名；
        3）单例模式中本模块之间的相互调用   this.属性名、方法名；
    2.单例模式的优缺点：
        优点：1.避免了变量名冲突  2.实现了模块式开发
        缺点：手工作业模式，一个个创建  低效率
        解决办法：工厂模式封装
二）工厂模式
    1.工厂模式的思想：三步骤   在函数里创建一个对象，然后最后把它返回
    需要自己手动创建一个对象，然后添加完属性和方法之后，return一个对象。
        1）引进原材料 var obj={}    var obj= new obj();
        2）产品加工 -js中给对象添加属性和方法
        3）输出产品 -js中输出对象；
    2.工厂模式：本质：函数封装  就相同的代码或者功能进行封装，以后再用，不用重写，直接调用即可；
    ---本质：函数封装  （封装的好处：低耦合，高内聚 避免大量代码冗余）
    缺点：没法解决产品差异化
三）构造函数模式
    什么是构造函数模式：目的是为了实现一个自定义的类（所有的类都是函数），并能创建一些实例；
    1.工厂模式和构造函数的区别：
        a.在执行的时候：
            工厂模式:-->函数调用;
            构造函数模式是一个new 类();
            所有的类都是函数，但是通过new创建出来的实例都是对象
        b.在里面js代码执行时候：
        工厂模式：需要自己手动创建一个对象，然后添加完属性和方法之后，return一个对象。
        构造函数模式：系统会自动创建一个对象，添加完属性和方法之后，系统会自动返回一个对象
    2.构造函数的细节：
        1）创建一个实例时，如果没有参数，小括号可以省略；
        2）关于this指向问题：
            构造函数中的this，指向实例；
            方法中的this:方法调用时，看前面是否有点，点前面是谁，this就是谁
        3）构造函数中，只有this.xx跟实例有关系，跟里面变量没有任何关系
        4)构造函数执行完，系统会默认返回一个对象，如果我们自己return一个返回值的话：
            1.return基本数据类型值，无效，返回的还是当前这个实例
            2.return引用数据类型，会覆盖掉当前时候实例，此时，实例上的属性和方法都无效了。
        5）构造函数中有name-》函数名,length（形参的个数），__proto__->指向所属类Function.prototype、prototype->它自己本身的原型。
    3.构造函数的优缺点：
        优点：自定义一个类（函数封装） 可以创建实例；而且系统会自动创建和返回对象
        缺点：每个方法都是私有的，导致大量冗余代码；（每创建一个实例的时候，私有的方法都会创建一遍，用或者不用的都有，出现大量冗余）
        解决办法：prototype  把相同的代码放在一个公共的区域；
四）原型模式
    1.学习原型的好处：
        1）解决了构造函数相同方法不相等的问题；
        2）方便我们学习对象上所有属性和方法
    2.instanceOf   检查一个对象是否属于某个类
    3.属性的判断：
        1）in:私有属性+公有属性；
         for  in可遍历私有属性和自己定义的共有属性
        2）hasOwnProperty:查看是否是对象上的私有属性
        3）需求：hasPubProperty:这个属性是否为对象上的公有属性
    4.构造函数和原型链的思维差别：
        构造函数：类  实例（围绕这两个之间的关系）
        原型模式： 实例  类  原型（围绕这三者间的关系）
    5.原型链基础知识：
        1）每一个函数(普通函数、构造函数也叫类、Object）都天生自带一个prototype的属性，这个prototype是个对象。
            所有的函数都有prototype属性，只有在构造函数上才有意义
        2）浏览器自带的prototype属性天生自带constructor属性（自己重构的prototype没有这个属性），属性值是当前这个类;原型对象上有，
     说明属于实例的公有属性，每个实例也都有，都指向这个类。constructor可以检测数据类型，但是不知道有没有重构，所以用instanceOf 更保险
        3）每个对象（普通对象、prototype、实例）都天生自带一个_proto_的属性，属性值：当前这个实例所属类的原型
*****Object是对象的祖师爷，但是属于类，而所有类都属于Function,所以Object instanceof  Function  返回true，
        因为可以新建一个对象new obj=new Object();
    6.原型解决的问题：原型prototype上存储的都是公有的属性和方法
    7.原型链是通过_proto_来实现
        原型链是一种查找机制：（原型链是实现继承的关键，是js中独有的一种机制）
        1.对象.属性  首先在自己的私有空间里查找，如果找到，就用私有空间的属性
        2.如果找不到，通过_proto_继续往该实例所属类的原型上找；如果找到，它是一个公有的属性；
        3.如果还找不到，继续通过_proto_往上级对象上找，一直找到Object.prototype...，如果还没找到-->undefined
    8.原型链
    //HTMLDivElement(div元素标签类----》每一个DIV元素对象都是这个类的实例，并且每一个HTML元素标签都有一个自己对应的类）
    //p标签对应的类--》HTMLParagraphElement
    //HTMLDivElement--》HTMLElement元素标签类 --》Element-->Node-->EventTarget--->Object （元素标签原型链）
    //->HTMLCollection(元素集合类 getElementsByTagName/getElementsByClassName)、
        NodeList(节点集合类 getElementsByName、childNodes)
    //HTMLdocument-->document-->node-->EventTarget--->Object （document 原型链）
    document（这上边有getElementById和createElement等方法，所以这些方法前只能是document)
    8.所有的类都是函数
    //js中的所有内置类：
    //****Math-->不是类，是对象，他只是一个对象，对象中存储了操作数字、数学的常用方法  ******记
    //-->Number.String Boolean (Undefined Null)  Object Function Array RegExp  Date
    9.Object是所有的对象的基类：(但是属于Function)
        1）f1 instanceof Object==>true;他可以通过_proto_一直找到Object这个类；
        2）Object这个类的原型上没有_proto_
        Function: 所有的函数都是Function的实例，所以的实例都是对象，所以所有函数同时是函数也是对象。（毁三观）
    10.prototype和_proto_的区别：
        prototype：存储公有的属性和方法
        _proto_:通过原型链，帮你一级级往上找你要的属性和方法--直到找到Object，没有的话返回undefined ，
        但是ie下_proto_不能找到上前实例所属类的原型
    11.实现链式操作
        链式写法：执行完成数组的一个方法，可以紧接着执行下一个方法
        1）原理：
        ary为什么可以使用sort方法？
            a.因为sort是Array.prototype上的公有方法，而数组ary是Array这个类的一个实例，
        所以ary可以使用sort方法---》只有数组才能使用Array原型上定义的属性和方法
            b.sort执行完成的返回值是一个排序后的“数组”--》数组可以再使用Array上的方法  reverse也一样
        但是pop()执行后的返回值是被删除的元素，不是一个数组，所以在他返回值的基础上使用数组的方法会报错。
    12.批量设置公有属性
        1）起一个别名，把原型对象的地址即类的prototype赋值给一个变量
        2）重构原型对象的方式--》自己新开辟一个堆内存，储存我们公有的属性和方法，把浏览器原来给prototype开辟的那个替换掉，
在浏览器空闲的时候会把原来的内存释放掉。******但是需要注意的细节如下：
           a.只有浏览器给prototype天生开辟的堆内存里才有constructor，而我们自己开辟的对内存里没有，所会去上级查找，最终找到的是Object
           为了和原来的保持一致，我们需要手动的增加一个指向，即添加一个constructor属性，属性值指向所属的类
           b.用这种方式给内置类增加去重的属性，会把之前已经存在于原型上的属性和方法给替换掉，所以我们在用这种方式去修改内置类的时候，
浏览器是会给屏蔽掉的。
         ---但是我们可以一个个的而修改内置类的方法，所以当我们以后通过以下方式在数组的原型上增加方法，
            如果方法名和原来的重复了，会把人家内置类的修改掉---》我们以后在内置类的原型上增加方法，命名都需要加特殊的前缀--》比如Jsort
    13.可枚举和不可枚举
********for in循环在遍历的时候，默认的可以把自己私有的和在所属类的原型上扩展的属性和方法都可以遍历到。
但是一般情况下，我们遍历一个对象只需要遍历私有的即可，我们可以使用以下的判断进行处理：（所以以后遍历对象的时候要这样多写一行代码）
        var obj={name:"zhufeng",age:7}
      for(var key in obj){
     1) if(obj.propertyIsEnumerable(key)){
            console.log(key);}
     2)一般用这种方法 if(obj.hasOwnproperty(key)){
            console.log(key);}
    14.Object.create(proObj) （实现多层继承） 创建一个新的对象，但是proObj 仍是这个对象的原型 相当于在obj和Object.prototype中间
    又加了一层在ie6-8不兼容（ECMAScript5）------
        也相当于在你需要的对象上创建一层（别人写的对象属性和方法，这样就不用覆盖你之前的原型，也可以用到新对象的属性。
    寄生组合式继承
    B.prototype=Object.create(A.prototype)但是Object.create不兼容
    所以重写一个方法：B.prototype=Object.create(A.prototype)
    function  ObjectCreate(obj){
    function Fn(){
    }
    Fn.prototype=obj;
    return new Fn;
    }
    15.继承方法
    继承：子类继承父类的属性和方法；
    *****原型继承：是基于原型链的*******
        1）call继承：把父类私有属性和私有方法克隆一份一摸一样的变成子类私有的。（具体可以查看正式课第一周周日的讲义--拷贝继承）
                   function B(){
                        A.call(this);}
        2） 拷贝继承（冒充对象继承）：把父类私有的和公有的克隆一份一模一样的给子类私有。for in 循环实现；（通过遍历，
       可以将一个对象的属性和属性值拷贝给另一个对象，然后对新的对象进行操作，就不影响父级）
            function B(){
               var temp=new A;
               for(var key in temp){
                 this[key]=temp[key];}
                }
        3）原型继承：是js中最常用的一种方式，子类B想要继承A中的所有属性和方法（私有+公有），只需要让B.prototype=new A即可。
         因为A的实例拥有这些属性和方法。
        //原型继承特点：它是把父类中私有的+公有的都继承到子类的原型上了（变成了子类公有的）。
        //原型继承的核心：并不是把父类中的属性克隆一份一模一样的给B,而是给B和A之间增加了原型链的链接，以后B的实例n，想要A中的getX方法，
        需要一级一级的向上查找来使用
        4）混合模式继承：原型模式继承+call继承  （工作中也很常用的一种方式）
            弊端：私有的会重复   因为call会继承私有的属性和方法，通过原型继承可以继承私有的和公有的，所以私有的属性和公有的属性有重复的。
        5）寄生组合式继承
          B.prototype=Object.create(A.prototype)但是Object.create不兼容
          所以重写一个方法：B.prototype=Object.create(A.prototype)
            function  ObjectCreate(obj){
                    function Fn(){
                        }
                        Fn.prototype=obj;
                    return new Fn;
                        }
        6)中间类继承法--不兼容-周氏继承法
****16.原型深入和函数Function深入
       1.Object：万物皆对象，包括所有的函数和大类Function（具体可看原型链终结版图片或者周啸天视频第21课函数的三种角色）
            除了Function.prototype，是函数数据类型不是对象，但是相关操作和之前的一模一样
            在控制台dir一下，会发现叫function Empty/anonymous()  （翻译前两个但是分别是空和匿名）所以是一个没有实际意义的函数
    17.call和apply、bind
        1.call/apply方法运行的时候，他们的作用：
            1)让点前面的方法里的this关键字变成第一个实参
            2)让点前面的方法运行
        **弊端：改变THIS指向后，让前边主体执行，所以有时候不太合适  用bind可以实现预处理，然后到时候方法自己执行的时候再执行。
        而且在严格和非严格模式下，对于第一个参数是null/undefined这种情况的规律也是一样的
        2. call/apply区别：
                call:(this指向，参数1，参数2）（找到执行call方法函数中的this，这个this是字符串
                apply:(this指向，[参数1，参数2])把参数放在一个数组里，但是相对于形参也是一个个的传的。
            1)传参的方式不一样，call是散列式的传参方式，apply是打包式的传参方式,call再给fn传递参数的时候，是一个个的传递值的，
        而apply不是一个个的传，而是要把给fn传递的参数统一的放在一个数组中进行操作。但是实际上，也是一个一个的传给方法的形参.
        在非严格模式下：arguments和当前函数定义的形参是存在映射关系的，
        但在严格模式下，arguments和当前函数定义的形参是不存在映射关系的，并且严格禁止我们用argumets.callee
        3.严格模式：
          fn();-->里的this也是undefined
          apply里传谁this就指向谁，不传就是undefined
        bind:这个方法在ie6-ie8不兼容  和call/apply类似，都是用来改变this关键字的。但是区别：只是改变了fn中this为obj,并且给fn传递
        了两个参数1和2，但是此时并没有让fn执行；但是bind会有一个返回值，如下赋值给一个变量tempFn，这个变量tempFn就是我们把fn的this
        改变后的结果。
      //预处理机制（思想）：事先把fn的this改变成我们想要的结果，并且把对应的参数值也准备好，以后要用了，直接执行就bind的返回值就可以了
        fn.bind(obj,1,2)
        var tempFn=fn.bind(obj,1,2);
         tempFn()
        4.关于apply的this指向问题（第二周周末第一天老师课件）
            关于fn1.apply()this指向问题：
            1）在非严格模式下：
                fn1(); //this-window;
                fn1.apply(null);//this-window;
                fn1.apply(undefined);//this-window;
                fn1.apply();//this-window;
            2)在严格模式下'use strict':
                fn1(); //this-undefined;(函数前面没有点)
                    //以下严格模式下，apply中this指向传谁，this就是谁，不传-undefined；
                    fn1.apply(null);//this-null;
                    fn1.apply(undefined);//this-undefined;
                    fn1.apply();//this-undefined;
            3）在工作中相对来说，非严格模式用的最多；
    18.原型图上的各种关系：
        1.任何对象（new出来的实例）最终都能通过__proto__找到Object
        2.所有类都是Function的实例
        3.Function是Object的爹，因为Object是类
        同时Object.prototype是Function.prototype的爹，因为Function.prototype属于对象，Object是对象中祖宗
*****Function
    19.函数的三种角色：（函数在整个JS中是最复杂也是最重要的知识）
        1.普通函数：当方法运行的时候，形成一个私有的作用域，1.形参赋值 2.预解释 3.代码从上往下执行
        2.构造函数（类）：new+函数名执行，通过这种方式运行的函数就成为构造函数，构造函数里有自己的原型对象（prototype），构造函数里
            通过this.xx=xx设置的属性都是实例的私有属性，prototype上的都是公有的。this表示某一个实例，hasOwnProperty可以判断是私有属性还是公有的属性
        3.函数也是对象，和普通对象obj={}一样，都有自己私有的属性和方法，公有的属性和方法。
            只是函数比较特殊，因此单独独立成Function类型  fn instanceof Object-->true  可以像对象一样设置自己属性和值
        这三种角色之间相互独立，没有关系
*******所有的函数(类）都是Function类的实例，所以所有的函数同时也是对象数据类型的  Object类也是Function
所有的对象都是Object类的实例     fn instanceof Object   Fn instanceof Object
        Function
        4.函数本身具有的属性：
            length:0  形参的个数
            name:"Fn"  函数名属性
            prototype:（本身是个爹，指向原型）类的原型，在原型上定义的方法都是这个类实例的公有方法
            __proto__：（函数本身也是个儿子，指向所属类Function的原型）把函数当做普通的对象，指向Function这个类的原型

        *****函数在整个JS中是最复杂也是最重要的知识：
        5.一个函数存在多面性
            1）“普通函数”：它本身就是一个普通的函数，执行的时候形成一个私有作用域（闭包），形参赋值，预解释，
            代码执行，执行完成后栈内存销毁和不销毁
            2）“类”：它有自己的实例，也有一个叫prototype的属性，指向自己的原型。
            3）“普通对象”：和var obj={}一样，就是一个普通的对象，他作为对象可以有一些自己的私有属性，
            也可以通过__proto__找到Function.prototype然而这三者之间是没有必然的关系的

</body>
</html>