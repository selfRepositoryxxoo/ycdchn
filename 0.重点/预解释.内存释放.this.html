<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
1.预解释：在当前作用域下，JS代码执行之前，浏览器会把带VAR和带function进行提前声明或者定义；
         域：空间或者范围；
2.预解释阶段的声明和定义的概念
    声明：告诉浏览器有这么一个名字；但是不知道值； eg:var a;
    定义：给之前声明的这个名字赋值；eg:var a=2;
    注：对带VAR和带function的声明和定义是不同的：
    带VAR：在预解释阶段，只声明，不定义；而且对于相同变量的名字（包含var或者函数名相等）只声明一次
*****带function：在预解释阶段，声明+定义；
 *****注意函数的赋值在预解释的时候相同名字，赋值会覆盖，而且，执行的时候会自动忽略定义的部分。直接走函数执行的语句。
3.作用域：全局作用域和私有作用域

    全局作用域：页面加载的时候，浏览器会提供一个供js代码执行的环境--》全局作用域
在全局作用域环境下，里面所有的变量和函数，实际上就是window的属性和方法；
    私有作用域：函数运行的时候（或在函数被调用的时候），也会提供一个供js代码执行的环境，形成一个私有作用域；
*******私有变量（针对函数）：函数里私有变量的概念：形参，私有变量（var 声明的变量）除了这两种，其他都不是，
所以看一个函数里边的变量是不是私有，先看有没有形参或者var。
*****如果形参名字和外边变量名字一样，需要注意，具体细分好多种情况，可以查看正式课第一周周六传参的问题总结。
4.函数定义和执行阶段：

    1）函数定义3阶段：
    1.开辟一个堆内存空间，浏览器默认为其分配一个地址；eg:xxff00;
    2.把函数体中的JS代码做为字符串存放在这个堆内存空间中
    3.把地址赋值给函数名；

    2）函数执行3阶段：
    1.给形参赋值
    2.预解释
    3.JS代码从上往下执行；
5.作用域链：在函数执行的时候，会形成一个私有作用域A，私有作用域中找一个变量,这个变量是否在作用域A中定义过：
    1）如果变量在A中定义过，那这个A中所有的此变量，都是私有变量；
    2）如果变量没在A中定义过，就会往A的上级作用域进行查找，有的话就赋值，没有就继续往上找，。。。找到window都没有，报错！
    怎么查找上级作用域
    //作用域链--（为了保证执行环境里的函数或者变量之间能够有序访问）*****
    //当前这个函数是在哪个作用域下定义的，上一个作用域就是谁  跟函数在哪执行是没有关系的
    //window作用域是最外层的作用域链  当前执行的函数是最前端的作用域链
6.带var和不带var的区别：
    1）带var：1）会预解释 2）如果带var在全局环境下，它是window的全局属性；
    2）不带var:1）不会预解释 2）首先会往上找；如果是赋值的话，找到window还没有，就变成window上的全局属性；
    1.var关键字的变量要预解释,不带var关键字的变量不需要预解释
    2.var num = 13;在全局作用域下定义了一个变量num= 13 ; window.num = 13
    num = 12;仅仅是给window增加了一个属性 window.num = 12;不预解释。
    3.第二种情况可以删除，第一种不能被删除

    在私有作用域中,不带var关键字的变量称为非私有变量,去它的上级作用域查找看是否有这个变量,
*****如果到window作用域下也没有找到，就会给window增加一个属性，但是没有声明，所以提前输出会报错，只能在之后输出。*****
    函数里不带var********就不是私有变量，如果往上一级找var，找到算上一级的变量，没找到，就算是给window增加了一个属性******
7.JS中的内存，按照功能的不同：
    1）栈内存：提供了一个供JS代码执行的环境：全局作用域，私有作用域；
    2）堆内存：存储引用数据类型的值； 对象数据类型：存属性和属性值； 函数数据类型：代码字符串；
8.传参问题深入理解：具体查看正式课第一周周六传参问题总结（arguments、形参、私有变量等）。
9.关于函数的无节操：
   无节操：
    1）不管if条件是否成立，都先预解释；
2）var 只要看到var都是声明左边变量，不看右边，不定义。（如果把函数赋值给变量，按变量来声明；）
****不需要预解释的几种情况********
1）自执行函数不预解释，只有执行到他的时候，声明+定义+执行同步完成；
2）在变量名相同的情况下，不重复声明，但会重新赋值；
3）如果函数有返回值return； return后面的值不进行预解释（返回值是当值存在的）；return下面的代码不执行，但是要进行预解释；
4）匿名函数之函数表达式，把函数部分当做一个值赋值给我们的变量（函数方法当值存在了）或者元素的某一个事件。
写项目时，最好写成这种赋值的方式，找bug直接找上边，因为执行肯定在函数定义的下边。

10.闭包的作用和功能（函数内参数传到函数外面）：
  闭包概念：当函数执行的时候，会形成一个私有作用域，能保护方法体里的内容不受外界的干扰，这种保护机制--》闭包（块级作用域）
    1）防止变量名冲突
    2）可以通过传参的方式，对全局变量的在私有作用域里重新赋值；
    2）闭包里面的值，如果想修改全局的值，window.xx=xx;
    3）闭包可以用来封装方法，最后通过window.方法名=方法名；自执行函数，在封装函数外边，自执行函数里边，
写上如window.prev=getPrev（这个是里边函数的方法名字的语句;即把这个函数的地址给了window）方法外边套一层按普通封装函数的把封装好的函数，
让外面可以用到；（具体查看正式课第一周周六闭包课件）
11.this
   //js中主要研究的是函数中的this,但并不是只有函数中有this
   //js中的this表示的是当前行为执行的主体；js中的context代表的是当前行为的环境
    //this是谁，与函数在哪定义和在哪执行的都没有关系；只和执行主体有关系：
       如何区分this呢？

********this总结 :***************
    在非严格模式下：
    1）自执行函数里的this，永远都是window；
       自执行函数：定义完成后就立马执行了
        str.replace(reg,function(){
        //this->window
            });
        window.setTimeout(function(){
        //this->window
        },10);
    2）给元素的某一个事件绑定方法，当事件触发的时候，执行这个绑定方法，绑定方法中（只是最上面的那一层，如果里边放一个方法，
那就按下一条函数调用来看了）的this（就是当前这个元素，不包含里边的函数中的THIS
        --》curEle.onclick=function(){}  this-->curEle
    3）函数调用的时候，看前面是否有'.'，有'.'的话，'.'前面是谁，this就是谁，没有的话就是window
       但是遇到数组或者对象里边的属性名是数字时，不能使用点来，只能写成方括号的形式，但它等同于点。
     对象和数组里面定义的方法，只能对象和数组自己调用，所以this就是这个对象或者数组。
        如下：
        var a=["a","b","c",function(){ alert(this)}];
        a[3]();--->this是这个数组，和obj.aa()是一个原理，但是数组无法使用点，而只能用方括号
         var obj={1:"a","attr":function(){ alert(this)}};
            obj.attr();
            obj["attr"]();//这两种形式是一样的
         var obj2={1:"a",3:function(){ alert(this)}};
            obj2[3]()-->因为这个对象属性名是3的不能使用点的形式写，必须用方括号，但是原理和点是一样的，所以
    4)构造函数中，方法体中的this.xx=xx中的this指的是当前类的一个实例
    5)在原型模式中，this常用的两种情况：
        a.类中的this.xx--》this表示当前的实例
        b.在某一个方法中的this--》看执行的时候点前边是谁，this就是谁
            1.需要先去定this的指向
            2.把this替换成对应的代码
            3.按照原型链查找机制，一步步的查找结果
    6)通过apply和call、bind可以改变this关键字，优先级最高，遇到call/apply/bind以上四条规则都不起作用
    call，apply、bind都可以改变this的指向（而且前几种都会失效）
        fn.call()   --》window
        fn.call(null)-》window
        fn.call(undefined)--》window
    在JS严格模式下"use strict"：
       1.自执行函数里的this永远是undefined不是window
       2.方法执行，看前边有没有点，有点前面是谁this就是谁，没有的话就是undefined(在非严格模式下，没有默认主体的时候默认是window）
    一般常用的是在非严格模式下的。
        fn.call()   --》undefined
        fn.call(null)-》undefined
        fn.call(undefined)--》undefined
        两者模式下的区别：非严格模式下的所有没有具体协商执行主体的，都默许THIS是window，
                            在严格模式下，没写的话，THIS默认undefined

12.内存释放和销毁
    1.内存释放：堆内存的释放和栈内存的释放；
    1）堆内存的释放：对象数据类型或者函数数据类型，在定义的时候，首先都会开辟一个堆内存，并且有一个引用地址，
        堆内存的地址，即函数定义的时候的引用地址是不会被销毁的。
如果外面有变量知道了这个地址（当堆内存赋值给变量时），我们就说这个内存被占用了，不能销毁了，无法释放；
***解决办法：变量=null（或者其他不是内存的值）；当变量指针为空的时候，浏览器会在空闲时把被释放的堆内存收回，这种机制-垃圾回收机制；
    2）栈内存释放
    全局作用域：在浏览器其加载完整个页面时，形成一个供全局使用的环境-全局作用域，只有关闭浏览器，才能彻底释放；
如果不关闭浏览器，这个全局环境中的变量和方法都无法释放；
    私有作用域（只有函数执行，才会产生私有作用域）：当函数执行完成时，私有作用域一般情况下会自动销毁；

****2.私有作用域不销毁情况************8
    1）不销毁（两种情况）：
       a.函数执行返回了一个引用类型的值，并且在函数的外面被其他的东西接受了，那么当前函数形成的私有作用域就不在销毁了。
    函数内包含另外一个函数，并将外面那层函数的返回值赋值给一个变量f.
       b.在一个私有的作用域中，给dom元素的事件绑定方法，一般情况下，我们的私有作用域都不销毁
        （具体查看正式课第二天内存释放问题--不释放的b类情况例子）
        在函数执行的时候,里面的一个小函数的地址赋值给了我们的外面元素的点击事件,那么当前小函数也相当于被外面占用了,
        大函数执行形成的私有的作用域也不销毁了
      **例如：每一次循环都执行自执行函数形成一个私有的作用域(循环三次就有三个作用域,每一个作用域中都有一个i,第一个存储的是0,
            第二个存数的是1..)，在每一个私有的作用域中都把里面的函数绑定给了外面元素的点击事件,这样的话每一次形成的作用域都不销毁了
            (三个不销毁的作用域)
            var oLis=document.getElementsByTagName("li");
            for(var i=0;i<oLis.length;i++){
            ~function(i){
            oLis[i].onclick=function(){
                tabChange(i);
                }
                }(i);
                }

        3)在使用setTimeout实现轮播动画的时候,我们如果move需要传递参数值,那么像下面这样的写法会行成很多的不销毁的作用域,非常的耗性能
                function move(tar){
                //window.setTimeout(move,10); ->第二次执行move的时候我们没有给它传值(这样写不行)
                 window.setTimeout(function(){
                  move(tar);
                  },10);//->这样写实现了,但是每一次执行定时器都会形成一个私有的所用域(匿名函数形成的)A,
                在A中使用了上级作用域中的tar的值,而且执行了move又形成了一个小的作用域(而在小的作用域中会使用tar的值),
                这样每一次定时器形成的A都不能销毁了
                 }
                    move(100);//->第一次这样执行传递100

                      //解决办法:
                 function move(tar){
                    ~function _move(){
                        window.setTimeout(_move,10);
                         }();
                         }
                         move(100);//->第一次这样执行传递100
        JS中内存空间释放的问题（堆内存、栈内存）
        [谷歌浏览器]
        我们开辟一个内存，可能或有一些其他的变量等占用了这个内存，谷歌浏览器都会间隔一段时间看这个内存还有没有被占用，
        如果发现有没有被占用的内存了，就自己帮我们回收了(内存释放)

        [火狐和IE]
        我们开个内存，当我们引用了它，就在内存中记录一个数,增加一个引用浏览器就把这个数+1，减少一个引用，浏览器就把这个数-1..
        .当减到零的时候浏览器就把这个内存释放了;但是有些情况下(尤其是IE)记着记着就弄乱了，内存就不能释放了-->浏览器的内存泄露

        var obj={};
        我们养成一个好的习惯，当我们obj这个对象使用完成了，我们手动的obj=null (null空对象指针)，浏览器会自己把刚才的堆内存释放掉

    2）不立即销毁--》fn返回的函数没有被其他的东西占用（即没有将引用地址给其他变量），但是还需要执行一次呢，所以暂时不销毁，
// 当返回的值执行完成后，浏览器会在空闲的时候把它销毁了
</body>
</html>